# -*- coding: utf-8 -*-
"""LSTM_Asset_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lMcSBSMvguMZcZfJiTm9NxqJi64cTaNj
"""

#installing the required library
!pip install tensorflow

#importing the necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM,Dense,Input,Concatenate,Dropout
from tensorflow.keras.optimizers import Adam
df=pd.read_csv("Google_Stock_Price_Train.csv")
print(df.head())

#data preprocessing
print(df.isnull().sum())
print(df.duplicated().sum())
print(df.info())

df['Date']=pd.to_datetime(df['Date'])

#plotting graphs and correlations
import seaborn as sns
plt.figure(figsize=(10,5))
#removing the comma from the volume and the close columns
df['Close'] = df['Close'].replace(',', '', regex=True).astype(float)
df['Volume'] = df['Volume'].replace(',', '', regex=True).astype(float)
df_num=df[['Open','High','Low','Close','Volume']]

sns.heatmap(df_num.corr(),annot=True)
plt.title("correlations between different numerical features of the dataset")
plt.show()

#plotting graphs
sns.relplot(data=df,x='Date',y='Close',kind='line')
plt.show()

sns.relplot(data=df,x='Date',y='Low',kind='line')

sns.relplot(data=df,x='Date',y='Open',kind='line')

sns.relplot(data=df,x='Date',y='High',kind='line')

#choosing the feature matrix and dependent vector
features = ['Open', 'High', 'Low', 'Volume']
target = 'Close'
#scaling the data
S = MinMaxScaler()
scaled_data=S.fit_transform(df[features + [target]])

X, y = [], []
window_size = 60


X, y = [], []
for i in range(window_size, len(scaled_data)):
    X.append(scaled_data[i-window_size:i, :-1])
    y.append(scaled_data[i, -1])

X, y = np.array(X), np.array(y)

# splitting the dataset
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

#training our LSTM model
model = Sequential([
    LSTM(64, return_sequences=False, input_shape=(X_train.shape[1], X_train.shape[2])),
    Dense(1)
])
model.compile(loss='mse',
              optimizer=Adam(learning_rate=0.001),
              metrics=['mean_absolute_error'])
model.fit(X_train, y_train, epochs=150, validation_data=(X_test, y_test))

#generating the prediction
preds = model.predict(X_test)
#printing y_test and preds
np.concatenate((preds.reshape(len(preds), 1), y_test.reshape(len(y_test), 1)), axis=1)

#generating the plot
dummy_preds = np.zeros((len(preds), scaled_data.shape[1]))
dummy_preds[:, -1] = preds.flatten()
preds_original_scale = S.inverse_transform(dummy_preds)[:, -1]


dummy_y_test = np.zeros((len(y_test), scaled_data.shape[1]))
dummy_y_test[:, -1] = y_test
y_test_original_scale = S.inverse_transform(dummy_y_test)[:, -1]


plt.plot(y_test_original_scale, label='Actual')
plt.plot(preds_original_scale, label='Predicted')
plt.legend()
plt.show()